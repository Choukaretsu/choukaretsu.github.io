<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从axios开始的javascript异步生活</title>
    <link href="/2022/09/07/axios/"/>
    <url>/2022/09/07/axios/</url>
    
    <content type="html"><![CDATA[<h1 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h1><p>学习来源：bilibili-尚硅谷视频教程&amp;&amp;Google</p><p>学习http，ajax，以及axios的各项配置，增强前端与后端交互方式的理解。</p><h1 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用"></a>axios的使用</h1><p>NPM输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs npm">npm install axios -S<br></code></pre></td></tr></table></figure><p>亦或者是网页引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="axios的方法"><a href="#axios的方法" class="headerlink" title="axios的方法"></a>axios的方法</h1><p>目前学习的主要是四种方法：</p><ul><li>GET  用于请求内容</li><li>POST 用于发送内容</li><li>DELETE 用于删除内容</li><li>PUT 用于修改内容</li></ul><h1 id="axios的基本使用方法"><a href="#axios的基本使用方法" class="headerlink" title="axios的基本使用方法"></a>axios的基本使用方法</h1><p>axios的使用是一个函数，函数内有一个对象参数，对象内包含了一定配置结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getbtn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">axios</span>(&#123;<br>            <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>            <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://localhost:8888/comments/2&#x27;</span>,<br>        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getbtn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">axios</span>(&#123;<br>            <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;POST&#x27;</span>,<br>            <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://localhost:8888/comments/2&#x27;</span>,<br>            <span class="hljs-attr">data</span>:&#123;<br>                <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好，这是不是一个测试&#x27;</span><br>            &#125;<br>        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure><p>此处演示了get和post方法来获得评论/发送评论的方式</p><p>需要注意的是get请求不能配置data</p><h1 id="axios的配置项"><a href="#axios的配置项" class="headerlink" title="axios的配置项"></a>axios的配置项</h1><h2 id="设定默认配置项"><a href="#设定默认配置项" class="headerlink" title="设定默认配置项"></a>设定默认配置项</h2><h3 id="axios-defaults"><a href="#axios-defaults" class="headerlink" title="axios.defaults"></a>axios.defaults</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">method</span> = <span class="hljs-string">&quot;GET&quot;</span><br></code></pre></td></tr></table></figure><p>设置默认请求类型为GET</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&quot;localhost...&quot;</span><br></code></pre></td></tr></table></figure><p>设置默认请求地址，函数内可省略</p><p>包括很多配置项，例如params，都可以通过defaults来设置默认值。</p><h2 id="函数内部配置"><a href="#函数内部配置" class="headerlink" title="函数内部配置"></a>函数内部配置</h2><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>请求目标链接</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>请求方法，例如GET PUT POST</p><h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><p>自定义请求头</p><h2 id="params"><a href="#params" class="headerlink" title="params"></a>params</h2><p>在URL中的请求参数（可能通常用于get），例如浏览器顶部的地址栏</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>对象，添加到请求体中（可能通常用于post请求）</p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>设定请求中断时间，单位毫秒</p><h3 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h3><p>申请跨域时是否需要凭证，布尔值</p><h3 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h3><p>认证信息，对象</p><h1 id="使用axios-create创建axios实例"><a href="#使用axios-create创建axios实例" class="headerlink" title="使用axios.create创建axios实例"></a>使用axios.create创建axios实例</h1><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;api.xxxx.org&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>:<span class="hljs-number">3000</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;foobar&#x27;</span>&#125;<br>&#125;)<br>  <span class="hljs-title function_">instance</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/getsomething&#x27;</span><br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response) <br>  &#125;)<br></code></pre></td></tr></table></figure><p>此处定义的instance和axios对象使用方式是几乎一致的，自身也可以当函数使用。</p><h1 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h1><p>官方解释：在请求或响应被 then 或 catch 处理前拦截它们。</p><h2 id="请求拦截器-amp-amp-响应拦截器"><a href="#请求拦截器-amp-amp-响应拦截器" class="headerlink" title="请求拦截器 &amp;&amp; 响应拦截器"></a>请求拦截器 &amp;&amp; 响应拦截器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 2xx 范围内的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应数据做点什么</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 超出 2xx 范围的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><strong>需要学习Promise</strong></p>]]></content>
    
    
    <categories>
      
      <category>程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>前端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flex学习笔记</title>
    <link href="/2022/08/25/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/25/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在鼎跃腾继续学习前端，今天老张要我学flex布局，就有了这一篇博客。</p><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><p>总结：flex布局可以为盒子模型提供很大的灵活性，任何一个容器都可以被指定为flex布局。</p><p>flex布局是一种称呼，其他包括伸缩布局弹性布局弹性盒布局，都说的是flex布局。</p><ul><li>当父盒子被设定为flex布局后，子元素的<strong>float</strong>、<strong>clear</strong>和vertical-align属性都将无效。</li><li>采用flex布局的父盒子称为容器，子元素称为元素。</li><li>子元素可以横向排列也可以纵向排列。</li></ul><h4 id="总结原理："><a href="#总结原理：" class="headerlink" title="总结原理："></a>总结原理：</h4><p>通过给父盒子添加flex属性，来达到控制子元素排列方式和位置的目的。</p><hr><h1 id="常见的父属性"><a href="#常见的父属性" class="headerlink" title="常见的父属性"></a>常见的父属性</h1><h4 id="CSS属性列表："><a href="#CSS属性列表：" class="headerlink" title="CSS属性列表："></a>CSS属性列表：</h4><ul><li>flex-direction:设置主轴方向</li><li>justify-content:设置主轴上子元素的排列位置</li><li>flex-wrap:设置子元素是否换行</li><li>align-content:设置侧轴上子元素的排列方式(多行)</li><li>align-items:设置侧轴上子元素的排列方式(单行)</li><li>flex-flow:复合属性相当于同时设置了flex-direction和flex-wrap</li></ul><h3 id="使用flex-direction改变主轴方向"><a href="#使用flex-direction改变主轴方向" class="headerlink" title="使用flex-direction改变主轴方向"></a>使用flex-direction改变主轴方向</h3><h4 id="主轴与侧轴的理解"><a href="#主轴与侧轴的理解" class="headerlink" title="主轴与侧轴的理解"></a>主轴与侧轴的理解</h4><p>在flex布局中，分为主轴和侧轴两个方向，同样的叫法还有行列，xy等。</p><p>默认的主轴方向就是X轴方向，水平向右。</p><p>默认的侧轴就是Y轴方向，水平向下。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="flex-direction可选的属性："><a href="#flex-direction可选的属性：" class="headerlink" title="flex-direction可选的属性："></a>flex-direction可选的属性：</h4><ul><li><p>row：默认从左到右</p></li><li><p>row-recerse：从右到左</p></li><li><p>colunm：从上到下</p></li><li><p>colunm-reverse：从下到上</p></li></ul><p>demo示例：</p><p><strong>代码部分</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>:<span class="hljs-number">80%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>预览图</strong></p><p><img src="/images/flex%E5%B8%83%E5%B1%80/flexdemo.png"></p><p>如果在flex- direction里将属性改为column</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: column;<br></code></pre></td></tr></table></figure><p>那么主轴就会从横向改为纵向：</p><p><img src="/images/flex%E5%B8%83%E5%B1%80/y%E8%BD%B4%E4%B8%BB%E8%BD%B4.png"></p><hr/><h3 id="使用justify-content来设置主轴上元素的排列方式"><a href="#使用justify-content来设置主轴上元素的排列方式" class="headerlink" title="使用justify-content来设置主轴上元素的排列方式"></a>使用justify-content来设置主轴上元素的排列方式</h3><p>justify-content定义了项目在主轴上的对齐方式</p><p><span style="color:red">注意⚠️：使用这个属性之前一定要确定好主轴是哪一个<span/> </p><h4 id="justify-content可选的属性："><a href="#justify-content可选的属性：" class="headerlink" title="justify-content可选的属性："></a>justify-content可选的属性：</h4><ul><li>flex-start：默认值，从头部开始。如果主轴是横轴，则从左到右。</li><li>flex-end：从尾部开始排列。</li><li>center：在主轴居中对齐(如果主轴是横轴则水平居中)</li><li>space-around：平分剩余空间(个人理解：沿主轴均匀排列，左右有边)</li><li>space-between：先两边贴边，再平分剩余空间(！重要！)</li></ul><p>其他都很好理解重点看space-between：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>:<span class="hljs-number">800px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: pink; </span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>:space-between;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果为：</p><p><img src="/images/flex%E5%B8%83%E5%B1%80/space-between.png"></p><p>相对来说，<span style='color:blue'>space-around<span/>就是两边有空间的</p><p><img src="/images/flex%E5%B8%83%E5%B1%80/space-around.png"></p><hr><h3 id="使用flex-wrap来设置子元素是否换行"><a href="#使用flex-wrap来设置子元素是否换行" class="headerlink" title="使用flex-wrap来设置子元素是否换行"></a>使用flex-wrap来设置子元素是否换行</h3><p>flex布局有个特性，就是当主轴元素塞不下的时候，会强制缩小元素的大小来进行排列。</p><p><span style="color:red">注意⚠️：默认不换行<span/> </p><p>属性只有两个：</p><p>no-wrap：默认值。不换行</p><p>wrap：换行。</p><hr><h3 id="使用align-items设置侧轴元素排列方式"><a href="#使用align-items设置侧轴元素排列方式" class="headerlink" title="使用align-items设置侧轴元素排列方式"></a>使用align-items设置侧轴元素排列方式</h3><ul><li>flex-start：默认排列</li><li>flex-end：从上到下</li><li>center：居中</li><li>stretch：拉伸</li></ul><p>待补充…</p><hr><h3 id="使用align-content设置多行排列方式"><a href="#使用align-content设置多行排列方式" class="headerlink" title="使用align-content设置多行排列方式"></a>使用align-content设置多行排列方式</h3><p>设置子项的多行排列方式。<span style="color:red">在单行下是没有效果的<span/> </p><ul><li>flex-start：默认值。在侧轴的头部开始排列</li><li>flex-end：在侧轴的尾部开始排列</li><li>center：在侧轴中间显示</li><li>space-around：子项在侧轴平分剩余空间</li><li>space-between：子项在侧轴分别位于两头，再平分剩余空间</li><li>stretch：设置子项高度平分父元素高度</li></ul><p> 待补充….</p><hr><h1 id="常见的子属性"><a href="#常见的子属性" class="headerlink" title="常见的子属性"></a>常见的子属性</h1><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语基础</title>
    <link href="/2020/12/01/%E6%97%A5%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/12/01/%E6%97%A5%E8%AF%AD%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="日语基础"><a href="#日语基础" class="headerlink" title="日语基础"></a>日语基础</h1><h4 id="日语书写分为假名和汉字"><a href="#日语书写分为假名和汉字" class="headerlink" title="日语书写分为假名和汉字"></a>日语书写分为假名和汉字</h4><p> ：从中国传入，具有一定意义的词。</p><p>假名：分为平假名和片假名</p><blockquote><p>平假名的作用：1.给日文中的汉字注音；2.表记和语词汇；3.作为文法助词。</p><p>片假名的作用：记录从英语等国家传来的外国词汇。</p></blockquote><h4 id="罗马字"><a href="#罗马字" class="headerlink" title="罗马字"></a>罗马字</h4><p>使用字母来作为标注的表记法。很类似拼音。</p><p>例如：<strong>SONY</strong> <strong>TOSHIBA</strong> <strong>TOYOTA</strong></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6学习笔记</title>
    <link href="/2020/06/08/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/08/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6学习笔记"><a href="#ES6学习笔记" class="headerlink" title="ES6学习笔记"></a>ES6学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学到哪里写到哪里，方便回头的时候复盘学习之路</p><h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><ul><li><p>变量不能重复声明。</p><p><code>let a = 1; let a =2; </code></p><p>会报错，但是var关键词不会。</p></li><li><p>let的作用域很小，只在代码块内实现，并且<strong>不存储在window对象里。</strong></p></li><li><p>不存在变量提升。</p></li><li><p>不影响作用域链。</p></li></ul><hr><h3 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h3><ul><li>值不能被修改的量被称为常量。</li><li>注意事项：<ul><li>必须要赋一个初始值，否则报错。</li><li>一般大写。</li><li>对数组和对象内的修改不算对常量的修改，不会报错。（因为常量的指向地址没有改变。）</li></ul></li></ul><hr><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul><li>es6标准支持了新的反引号，并且支持换行符</li></ul><p><code>&lt;script&gt; let list = `&lt;ul&gt;             &lt;li&gt;炼狱小镇&lt;/li&gt;             &lt;li&gt;核子危机&lt;/li&gt;             &lt;li&gt;荒漠迷城&lt;/li&gt;             &lt;/ul&gt;`;     &lt;/script&gt;</code></p><h4 id="变量拼接"><a href="#变量拼接" class="headerlink" title="变量拼接"></a>变量拼接</h4><p><code>let name = &#39;zjl&#39;;</code></p><p><code>let out = `我的名字叫$&#123;name&#125;`；</code></p><p><code>console.log(out)</code></p><p>正常输出。</p><hr><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><code>let fn =  () =&gt; &#123;</code></p><p><code>Something...</code></p><p><code>&#125;</code></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>箭头函数的this始终指向声明时所在的作用域</li><li>箭头函数不能作为构造函数</li><li>没有arguments变量</li></ul><h4 id="箭头函数的省略形式"><a href="#箭头函数的省略形式" class="headerlink" title="箭头函数的省略形式"></a>箭头函数的省略形式</h4><ul><li>当有且只有一个形参时，可以省略小括号。</li></ul><p><code>let add = n =&gt;&#123;</code></p><p><code>return n+n;</code></p><p><code>&#125;</code></p><p>此处省略了小括号。</p><ul><li><p>当只有一条语句时，还可以省略花括号。</p><p>​    <code>let pow = (n) =&gt; n*n;</code></p></li></ul><p>注意：此处也要省略return。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery笔记</title>
    <link href="/2020/03/26/jQuery%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/26/jQuery%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h1><h5 id="jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write-Less，Do-More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。"><a href="#jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write-Less，Do-More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。" class="headerlink" title="jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。"></a>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（<em>或JavaScript框架</em>）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</h5><h5 id="jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。"><a href="#jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。" class="headerlink" title="jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。"></a>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。</h5><p><em>——摘自百度百科</em></p><p>其实jQuery就是一个js文件，提供了一些方法，和特效。</p><hr><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>jQuery的核心就是选择器。</p><p>jQuery框架的关键字是<code>$</code></p><p><span style="color:red">特别注意：</span>如果jQuery选择了找不到的东西，并不会返回undefined，而是返回一个空数组。</p><hr><h3 id="普通选择器"><a href="#普通选择器" class="headerlink" title="普通选择器"></a>普通选择器</h3><p>按ID查找：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;#id&#x27;</span>);<br></code></pre></td></tr></table></figure><p>按标签查找：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;tagname&#x27;</span>);<br></code></pre></td></tr></table></figure><p>按类查找：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;.class&#x27;</span>);<br></code></pre></td></tr></table></figure><p>以上是标准选择器。</p><hr><h4 id="不仅如此，jQuery还可以通过属性查找。"><a href="#不仅如此，jQuery还可以通过属性查找。" class="headerlink" title="不仅如此，jQuery还可以通过属性查找。"></a>不仅如此，jQuery还可以通过属性查找。</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ (<span class="hljs-string">&#x27;[name=&quot;email]&#x27;</span>);<span class="hljs-regexp">//</span>找出所有含有这个属性的tag<br></code></pre></td></tr></table></figure><p><span style="color:red">注：属性需要转义，使用方括号圈起来。</span></p><h4 id="组合查找和多项查找"><a href="#组合查找和多项查找" class="headerlink" title="组合查找和多项查找"></a>组合查找和多项查找</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;input[name=email]&#x27;</span>)/;/仅查找input里的email属性<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;p.red&#x27;</span>);<span class="hljs-comment">//把class为red的p标签都选出来</span><br></code></pre></td></tr></table></figure><p><em>jquery支持多项查找，不同的属性之间用英文逗号分隔。</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;p,div&#x27;</span>);<span class="hljs-comment">//把p和div都选出来</span><br></code></pre></td></tr></table></figure><h2 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;ul.lang li.zjl&#x27;</span>);<span class="hljs-comment">//先选择ul,在选择li</span><br></code></pre></td></tr></table></figure><p>这个相当于先定位老爹，再找儿子。</p><h2 id="父子选择器"><a href="#父子选择器" class="headerlink" title="父子选择器"></a>父子选择器</h2><p>父子选择器和层级类似，但是限定了必须是父子关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ (<span class="hljs-string">&#x27;ul&gt;li&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>不仅是选择，我们还可以过滤掉不需要的东西。</p><p>过滤器的关键字为<code>:</code>;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ (<span class="hljs-string">&#x27;#div:first-child&#x27;</span>);<span class="hljs-regexp">//</span>仅选出第一个子节点<br>$ (<span class="hljs-string">&#x27;#div:last-child&#x27;</span>);<span class="hljs-regexp">//</span>仅选出最后一个子节点<br>$ (<span class="hljs-string">&#x27;#div:nth-child(2)&#x27;</span>);<span class="hljs-regexp">//</span>选出第n个元素，n的起始值为<span class="hljs-number">1</span><br>$ (<span class="hljs-string">&#x27;#div:nth-child(even)&#x27;</span>);<span class="hljs-regexp">//</span>仅选出偶数部分<br>$ (<span class="hljs-string">&#x27;#div:nth-child(odd)&#x27;</span>);<span class="hljs-regexp">//</span>仅选出奇数部分<br></code></pre></td></tr></table></figure><h3 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h3><p>针对表单元素，jQuery还有一组特殊的选择器：</p><ul><li><code>:input</code>：可以选择<code>，</code>，<code>和</code>；</li><li><code>:file</code>：可以选择``，和<code>input[type=file]</code>一样；</li><li><code>:checkbox</code>：可以选择复选框，和<code>input[type=checkbox]</code>一样；</li><li><code>:radio</code>：可以选择单选框，和<code>input[type=radio]</code>一样；</li><li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个``上，用<code>$(&#39;input:focus&#39;)</code>就可以选出；</li><li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</li><li><code>:enabled</code>：可以选择可以正常输入的<code>、</code> 等，也就是没有灰掉的输入；</li><li><code>:disabled</code>：和<code>:enabled</code>正好相反，选择那些不能输入的。</li></ul><hr><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1028321864402080">https://www.liaoxuefeng.com/wiki/1022910821149312/1028321864402080</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM学习笔记</title>
    <link href="/2020/03/20/DOM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/20/DOM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h1><ul><li>DOM 是 Document Object Model（文档对象模型）的缩写。</li><li>DOM的主体是document对象。</li><li>我们通过DOM来操作html的增删改查。</li><li>DOM不可以操作CSS，但是可以操作样式。</li><li>Dom操作为我们提供了一系列接口，方便我们让js和html互动。</li></ul><hr><h1 id="Dom的核心是节点。"><a href="#Dom的核心是节点。" class="headerlink" title="Dom的核心是节点。"></a>Dom的核心是节点。</h1><p>在w3c标准中，html的一切都是节点。</p><p>看一段demo：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sec=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;section&#x27;</span>)[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>在HTML部分，我们在section里放了个p标签和span标签，并且把节点定位到了section，那么我们现在看看section下有多少字节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sec.<span class="hljs-property">childNodes</span> <span class="hljs-comment">// NodeList(5) [text, p, text, span, text]</span><br></code></pre></td></tr></table></figure><p>有五个节点！</p><p>细看这五个节点，我们可以分析出其实这五个节点翻译过来就是：</p><p>1.section标签后面部分，节点属性为text。</p><p>2.p标签里面。节点属性为p（标签）</p><p>3.p标签后面。属性text。</p><p>4.span标签里面。属性标签</p><p>5.span标签后面。属性text。</p><h4 id="但是，我们并不是每次都要用这么复杂的字节点，我们可以只返回标签节点，毕竟这个最常用。"><a href="#但是，我们并不是每次都要用这么复杂的字节点，我们可以只返回标签节点，毕竟这个最常用。" class="headerlink" title="但是，我们并不是每次都要用这么复杂的字节点，我们可以只返回标签节点，毕竟这个最常用。"></a>但是，我们并不是每次都要用这么复杂的字节点，我们可以只返回标签节点，毕竟这个最常用。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sec.<span class="hljs-property">children</span> <span class="hljs-comment">//HTMLCollection(2) [p, span]</span><br></code></pre></td></tr></table></figure><p>我们可以发现，其实字节点返回的是一个<span style="color:red">类数组</span>。</p><p><em>有关类数组的知识点，可以看数组笔记。</em></p><hr><h1 id="Dom选择器"><a href="#Dom选择器" class="headerlink" title="Dom选择器"></a>Dom选择器</h1><p>获取节点，就要用选择器，选择器还挺多的，而且各不相同。</p><ul><li><p>document.getElementById()<br>使用ID来定位唯一的一个节点。</p></li><li><p>document.getElementsByTagName()<br>利用标签名定位一个类数组。（返回的是一串标签，如果需要精准定位，需要用[]。</p></li><li><p>document.getElementsByClassName()<br>利用class名定位。</p></li><li><p>querySelector()<br>css定位，返回第一个内容。</p></li><li><p>querySelectorAll()<br>css定位，返回所有内容。</p></li></ul><p><span style="color:red">值得注意的是，css定位选择的节点并不是实时更新的，尽量用document定位。</span></p><hr><h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h1><ul><li>元素</li><li>属性</li><li>文本</li><li>注释</li><li>document(整个文档)</li></ul><hr><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组复习笔记</title>
    <link href="/2020/03/20/%E6%95%B0%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/20/%E6%95%B0%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数组的基本概念"><a href="#数组的基本概念" class="headerlink" title="数组的基本概念"></a>数组的基本概念</h1><ul><li>数组是一个对象(Object)。</li><li>数组是很多属性的集合。</li><li>数组默认第一位是0。</li><li>数组中可以包含任意类型。</li><li>数组用[]表示。</li><li>js的数组不会有越界错误，长度可以自定义。</li><li>数组里还可以套数组。</li></ul><hr><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>数组内部有很多自带的方法，这些方法你可以用，也可以自己重做。</p><p>我们以以下数组作为例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">112</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">112</span>,<span class="hljs-number">423</span>,<span class="hljs-number">6124</span>,<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><p>搜查一个元素的指定位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">6124</span>) <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>slice方法会截取数组的一部分，并返回一个新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//(5) [4, 112, 423, 6124, 7] 前面两个就被截掉了</span><br></code></pre></td></tr></table></figure><p>亦或者是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//从第一位开始，到第三位结束（但是不包括第三位</span><br><span class="hljs-comment">//返回值：</span><br>(<span class="hljs-number">3</span>) [<span class="hljs-number">112</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="push-和pop-方法"><a href="#push-和pop-方法" class="headerlink" title="push()和pop()方法"></a>push()和pop()方法</h2><p>push方法可以在数组末尾继续增加一个元素，pop方法会删除数组最后一个元素。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">pop</span>()<span class="hljs-comment">//返回7 pop方法只返回删除了的元素。</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;x&quot;</span>);<span class="hljs-comment">//(8) [112, 1, 4, 112, 423, 6124, 7, &quot;x&quot;]</span><br></code></pre></td></tr></table></figure><h1 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h1><p>往数组头部加入元素可以用unshift()，而shift()可以把数组第一个元素截掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>arr1; <span class="hljs-comment">//[1,2]</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>arr1 <span class="hljs-comment">//var arr1 = [1,2];</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JavaScript闭包</title>
    <link href="/2020/03/08/JavaScript%E9%97%AD%E5%8C%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/08/JavaScript%E9%97%AD%E5%8C%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><h3 id="要了解闭包，首先我们要复习一下作用域。"><a href="#要了解闭包，首先我们要复习一下作用域。" class="headerlink" title="要了解闭包，首先我们要复习一下作用域。"></a>要了解闭包，首先我们要复习一下作用域。</h3><p>我们来看以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1219</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(a); <span class="hljs-comment">//可以正常运行</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1113</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">callB</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(b); <span class="hljs-comment">//正常运行</span><br>    &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(b); <span class="hljs-comment">//无法正常运行，b已经被销毁</span><br></code></pre></td></tr></table></figure><p>我们可以看到，在这个片段中，我们var了外部变量a，函数内变量b。并且发现，函数内部是可以访问外部变量的，但是外部是无法访问函数内部的变量的，这就是作用域。</p><hr><h4 id="接下来我们来看闭包。"><a href="#接下来我们来看闭包。" class="headerlink" title="接下来我们来看闭包。"></a>接下来我们来看闭包。</h4><p>先看定义：</p><p>高级程序设计：闭包是指有权访问另外一个函数作用域中的变量的函数.</p><p>但凡内部的函数被保存到了外部，它一定生成闭包。</p><p>外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象</p><br/><p>接下来我们做个测试。当我们需要一个数的两倍时，我们通常会这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Plus</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x+x;<br>&#125;<br><br><span class="hljs-title class_">Plus</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//返回20</span><br></code></pre></td></tr></table></figure><p>但有时候，我们并不需要现在就求和，这时候应该怎么办呢？</p><p>我们可以返回求和的函数。</p><p><span style="color:red;">注：在高阶函数中，可以把函数作为返回值。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy_plus</span>(<span class="hljs-params">x</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> plus=<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> x + x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> plus;<br>&#125;<br><br><span class="hljs-keyword">var</span> f1 = <span class="hljs-title function_">lazy_plus</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-attr">console</span>:<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure><p>我们可以看到，在这段代码里，我们调用lazy_plus时，返回的是一个函数。再用f1把函数保存到外部。</p><p>我们在lazyplus里又定义了一个plus函数，并且内部函数可以调用lazyplus的参数和局部变量，当lazyplus返回plus函数时，把参数和变量都保存在返回的函数中，这种程序结构被称为闭包(Closure)。</p><hr><h1 id="闭包的几大应用："><a href="#闭包的几大应用：" class="headerlink" title="闭包的几大应用："></a>闭包的几大应用：</h1><h4 id="1-做一个简单的计数器"><a href="#1-做一个简单的计数器" class="headerlink" title="1.做一个简单的计数器"></a>1.做一个简单的计数器</h4><p>代码部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Colck</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<span class="hljs-comment">//设定初始值</span><br>    <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//真正的返回值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<span class="hljs-comment">//返回函数</span><br>&#125;<br><span class="hljs-keyword">var</span> fc = <span class="hljs-title class_">Colck</span>();<span class="hljs-comment">//在外部执行</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://s1.ax1x.com/2020/03/16/8YVgsJ.png" alt="8YVgsJ.png"></p><hr><h1 id="快速计算x的二次方和三次方"><a href="#快速计算x的二次方和三次方" class="headerlink" title="快速计算x的二次方和三次方"></a>快速计算x的二次方和三次方</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">unction <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-comment">//返回带一个形参的函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//快速计算二次幂</span><br><span class="hljs-keyword">var</span> pow3 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//快速计算三次幂</span><br><br><span class="hljs-title function_">pow2</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 25</span><br><span class="hljs-title function_">pow3</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><p>这个例子中，我们通过闭包的手法，简化了幂运算的功能。只需要一个参数，就可以快速计算二次方和三次方。</p><h3 id="本章完。"><a href="#本章完。" class="headerlink" title="本章完。"></a>本章完。</h3>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown笔记</title>
    <link href="/2020/03/01/md/"/>
    <url>/2020/03/01/md/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种轻量级的标记语言，通过简单的语法，可以让文字拥有一定的格式。由于简单方便，通常用于写文档、博客等。本文就是使用Markdown+vs code进行编辑的。<br><br/><br><br/></p><h1 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h1><p>Markdown使用#号来标记标题。和HTML语法类似，Markdown也有1～6级标题可供选择。具体实现如下：</p><h1 id="我是一级标题"><a href="#我是一级标题" class="headerlink" title="# 我是一级标题"></a># 我是一级标题</h1><h2 id="我是二级标题"><a href="#我是二级标题" class="headerlink" title="## 我是二级标题"></a>## 我是二级标题</h2><h3 id="我是三级标题"><a href="#我是三级标题" class="headerlink" title="### 我是三级标题"></a>### 我是三级标题</h3><h5 id="我是四级标题"><a href="#我是四级标题" class="headerlink" title="##### 我是四级标题"></a>##### 我是四级标题</h5><h6 id="我是五级标题"><a href="#我是五级标题" class="headerlink" title="###### 我是五级标题"></a>###### 我是五级标题</h6><h6 id="我是六级标题"><a href="#我是六级标题" class="headerlink" title="###### 我是六级标题"></a>###### 我是六级标题</h6><p>从五级标题开始，字就比正文要小了。<br><br/></p><h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><p>同样和HTML类似，markdown拥有无序列表和有序列表两种表现方法。<br/><br>例：</p><h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><ul><li>泡面</li><li>巧克力</li><li>炸鸡</li><li>可乐<h3 id="实现方法如下："><a href="#实现方法如下：" class="headerlink" title="实现方法如下："></a>实现方法如下：</h3><code>* 泡面</code><br/>`* 巧克力`<br/>` * 炸鸡`<br/>`* 可乐`<br/></li></ul><h2 id="值得注意的是，md语法依赖空格，写的时候需要注意加空格。"><a href="#值得注意的是，md语法依赖空格，写的时候需要注意加空格。" class="headerlink" title="值得注意的是，md语法依赖空格，写的时候需要注意加空格。"></a>值得注意的是，md语法依赖空格，写的时候需要注意加空格。</h2><br/><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><ol><li>第一名</li><li>第二名</li><li>第三名<br/><br/></li></ol><h2 id="实现方法如下和例子一样，只需要在前面加数字-”-”即可。"><a href="#实现方法如下和例子一样，只需要在前面加数字-”-”即可。" class="headerlink" title="实现方法如下和例子一样，只需要在前面加数字+”.”即可。"></a>实现方法如下和例子一样，只需要在前面加数字+”.”即可。</h2><h1 id="markdown特殊字体"><a href="#markdown特殊字体" class="headerlink" title="markdown特殊字体"></a>markdown特殊字体</h1><p>markdown支持以下几种字体：</p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>又粗又斜的文本</strong></em></p><hr><p>实现方法如下</p><p><code>*斜体文本*</code></p><p><code>**粗体文本**</code></p><p><code>***又粗又斜***</code></p><hr><h1 id="markdown分割线"><a href="#markdown分割线" class="headerlink" title="markdown分割线"></a>markdown分割线</h1><p><code>***</code></p><p>如上即可</p><br/><br/><hr><h1 id="markdown区块"><a href="#markdown区块" class="headerlink" title="markdown区块"></a>markdown区块</h1><p>markdown使用”&lt;”符号来分割区块。例：</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p><blockquote><p>第四层<br><br/></p></blockquote></blockquote></blockquote></blockquote><p>实现方法：</p><figure class="highlight plaintext"><figcaption><span>第一层</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs >">&gt;<br>&gt; &gt;第二层<br>&gt; &gt;<br>&gt; &gt;&gt; 第三层<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; 第四层```<br>&lt;br/&gt;<br>***<br><br>列表内，也可以使用区块。<br><br>***<br><br># markdown显示code<br><br>在markdown里可以在前后用反引号 &quot;`&quot; 来显示一小块代码 例：<br><br>`console.log`<br><br>前后加三个反引号的话可以形成代码块：<br><br>```javascript<br> this.domTab.rows[this.foodPos.y].cells[this.foodPos.x].className=&quot;sfood&quot;;<br>    document.getElementById(&quot;foodNum&quot;).innerHTML=this.foodNum++;<br></code></pre></td></tr></table></figure><p>结束。</p><hr><h1 id="markdown插入链接"><a href="#markdown插入链接" class="headerlink" title="markdown插入链接"></a>markdown插入链接</h1><p><a href="www.baidu.com">Baidu</a></p><p>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p><p>以上都是插入链接的两种方式。具体实现：</p><p>[链接名称](链接地址)</p><p>&lt;链接地址&gt;</p><h1 id="markdown插入图片"><a href="#markdown插入图片" class="headerlink" title="markdown插入图片"></a>markdown插入图片</h1><p><code>![alt 属性文本](图片地址 “可选择标题”）</code></p><p><img src="../finder.png" alt="finder"></p><p>注：md目前无法设定图片大小，需要的话要用img src来插入。</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
